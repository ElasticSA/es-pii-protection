
input {
  elastic_agent {
    port => 15001
    ecs_compatibility => "v8"
    ssl_enabled => true
    # This is the PKI configured in the Fleet LogStash output
    # We don't cover here how to set this up (I use cert-manger in k8s)
    ssl_certificate_authorities => ["/use/share/logstash/config/tls1/ca.crt"]
    ssl_certificate => "/use/share/logstash/config/tls1/tls.crt"
    ssl_key => "/use/share/logstash/config/tls1/tls.key"
    ssl_client_authentication => "required"
  }
}

filter {
  ####################################################################
  # Elastic Integration (ECS)
  ####################################################################
  elastic_integration {
    hosts   => "${ES_HOSTS}"
    api_key => "${ES_APIKEY}"
  }
  ####################################################################
  # PII encryption
  ####################################################################
  ruby {
    init => '
      require "openssl"
      require "base64"
      require "securerandom"
      require "digest"
      require "ipaddr"
      @pii_keys = %w[
        name full_name first_name last_name email username hostname
        mac id domain roles ip
      ]
      @base_key = ENV["PII_KEY"]
      raise "PII_KEY not set" unless @base_key
      # Pre-create cipher template
      @cipher_template = OpenSSL::Cipher.new("AES-256-CBC")
      def aes_encrypt(value, salt)
        cipher = @cipher_template.dup
        cipher.encrypt
        cipher.key = Digest::SHA256.digest(@base_key + salt)
        iv = cipher.random_iv
        cipher.iv = iv
        encrypted = cipher.update(value.to_s) + cipher.final
        Base64.strict_encode64(iv + encrypted)
      end
      def encrypt_scalar(field, value)
        salt = SecureRandom.hex(3)
        enc  = aes_encrypt(value, salt)
        "#{field}:#{salt}:#{enc}"
      end
      # Reversible IP cipher
      def encrypt_ip(ip_str)
        ip = IPAddr.new(ip_str)
        if ip.ipv4?
          key = Digest::SHA256.digest(@base_key)[0,2].unpack1("n")
          prefix = ip.to_i & 0xFFFF0000
          suffix = ip.to_i & 0x0000FFFF
          enc_suffix = (suffix + key) & 0xFFFF
          IPAddr.new(prefix | enc_suffix, Socket::AF_INET).to_s
        else
          key = Digest::SHA256.digest(@base_key)[0,8].unpack1("Q>")
          prefix = (ip.to_i >> 64) << 64
          suffix = ip.to_i & ((1 << 64) - 1)
          enc_suffix = suffix ^ key
          IPAddr.new(prefix | enc_suffix, Socket::AF_INET6).to_s
        end
      end
      def walk(event, value, path)
        if value.is_a?(Hash)
          value.each do |k, v|
            walk(event, v, path + [k])
          end
        elsif value.is_a?(Array)
          value.each_with_index do |v, i|
            walk(event, v, path + [i])
          end
        else
          field = path.last.to_s
          return unless @pii_keys.include?(field)
          ref = path.map { |p| "[#{p}]" }.join
          if field == "ip"
            begin
              event.set(ref, encrypt_ip(value))
            rescue
              # ignore invalid IP
            end
          else
            event.set(ref, encrypt_scalar(field, value))
          end
        end
      end
    '
    code => '
      walk(event, event.to_hash, [])
    '
  }
}

output {
  elasticsearch {
    hosts  => "${ES_HOSTS}"
    api_key => "${ES_APIKEY}"
    data_stream => "true"
    data_stream_auto_routing => true
    pipeline => "_none"
    silence_errors_in_log => ["version_conflict_engine_exception"]
    manage_template => false
    ssl_enabled => true
  }
}
